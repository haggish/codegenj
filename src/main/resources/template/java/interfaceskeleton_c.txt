/* Source generated by codegenj (https://github.com/olir/codegenj) - DO NOT EDIT!
 *
 * This generated output is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * 
 * For more information, please refer to <http://unlicense.org>
 */

#include <stdio.h>
#include <stdlib.h>
#include "$$$interface.jname$$$.h"
#include "$$$library$$$-codegen.h"



// from de/serviceflow/codegenj/ObjectManager.c
JNIEnv *attachCurrentThread();
void detachCurrentThread();

struct NativeReferenceStructure;

typedef struct NativeReferenceStructure { 
  GObject *value;
} NativeReference;



typedef struct _MyObjectClass MyObjectClass;
typedef struct _MyObject MyObject;

struct _MyObjectClass
{
  GObjectClass parent_class;
};

struct _MyObject
{
  GObject parent_instance;

};

static GType my_object_get_type (void);
G_DEFINE_TYPE (MyObject, my_object, G_TYPE_OBJECT);

static void
my_object_finalize (GObject *object)
{
  MyObject *myobj = (MyObject*)object;



  G_OBJECT_CLASS (my_object_parent_class)->finalize (object);
}

static void
my_object_init (MyObject *object)
{

}

static void
my_object_class_init (MyObjectClass *class)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (class);

  gobject_class->finalize = my_object_finalize;
}

	GThread *$$$interface.jname$$$Skeleton_export_thread;
	GMainLoop *$$$interface.jname$$$Skeleton_export_loop;

	struct ExportThreadDataStructure;
	typedef struct ExportThreadDataStructure { 
		MyObject *obj;
//		$$$interface.uname$$$ *gskeleton;
		jobject *javaInstance;
	    const gchar *gpath;
	} ExportThreadData;

/*
##for method##
    void on_handle_$$$interface.jname$$$Skeleton_$$$method.jname$$$ ($$$interface.uname$$$ *skeleton,
        GDBusObject *object, gpointer user_data) {
        
        jobject *thisObj = (jobject *)user_data;
        
		g_print (" * on_handle_$$$interface.jname$$$_$$$method.jname$$$() called.\n");
			
		JNIEnv *env = attachCurrentThread();
		
		// return forward_$$$interface.jname$$$_$$$method.jname$$$($$$method.skeleton.jniparams$$$);
		
		// return  error_message(conn, msg,
		//			"org.bluez.Error.Rejected", "???");
		
		detachCurrentThread();
    }
##end##
*/

static GVariant *
$$$interface.jname$$$Skeleton_handle_get_property (GDBusConnection  *connection,
                     const gchar      *sender,
                     const gchar      *object_path,
                     const gchar      *interface_name,
                     const gchar      *property_name,
                     GError          **error,
                     gpointer          user_data) {
  return NULL;
}

static gboolean
$$$interface.jname$$$Skeleton_handle_set_property (GDBusConnection  *connection,
                     const gchar      *sender,
                     const gchar      *object_path,
                     const gchar      *interface_name,
                     const gchar      *property_name,
                     GVariant         *value,
                     GError          **error,
                     gpointer          user_data) {
  return TRUE;
}	

static void
$$$interface.jname$$$Skeleton_handle_method_call (GDBusConnection       *connection,
                    const gchar           *sender,
                    const gchar           *object_path,
                    const gchar           *interface_name,
                    const gchar           *method_name,
                    GVariant              *parameters,
                    GDBusMethodInvocation *invocation,
                    gpointer               data) {
 
 
    // NEVER CALLED - BUG !?
    g_print ( " ++ handle_method_call: %s\n", method_name );
    
	jobject *callbackObj = ((ExportThreadData *) data)->javaInstance;
    
	JNIEnv *env = attachCurrentThread();
		
    // TODO: lookup and call java methods related to method_name within new thread, deliver return value async
		// jclass cls = (*env)->FindClass(env, "de/serviceflow/codegenj/ObjectManager"); - todo generate class name
		//jmethodID mid = (*env)->GetStaticMethodID(env, cls, "dispatchObjectManagerSignal", 
	  	//			"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V");
	  	//	(*env)->CallVoidMethod(env, cls, mid, _signalname, _objectpath, NULL, NULL);  -- use callbackObj
		

	detachCurrentThread();
     
    g_dbus_method_invocation_return_value (invocation, NULL);
}

static const GDBusInterfaceVTable $$$interface.jname$$$Skeleton_interface_vtable =
{
  $$$interface.jname$$$Skeleton_handle_method_call,
  $$$interface.jname$$$Skeleton_handle_get_property,
  $$$interface.jname$$$Skeleton_handle_set_property
};


gpointer $$$interface.jname$$$Skeleton_exit_export_thread (void *data) {
	g_main_loop_quit ($$$interface.jname$$$Skeleton_export_loop);
	$$$interface.jname$$$Skeleton_export_thread = NULL;
	return NULL;
}


void $$$interface.jname$$$Skeleton_alert() {
        g_print ( "+++ ALERT +++\n" );
}

void $$$interface.jname$$$Skeleton_on_bus_acquired(GDBusConnection *connection, const gchar *name, gpointer data) {
	if (connection==NULL) {
        g_print ( "ERROR: on_bus_acquired(): no connection\n" );
        return;
	}

	// register objects here

	// $$$interface.uname$$$ *skeleton = ((ExportThreadData *) data)->gskeleton;
	// jobject *callbackObj = ((ExportThreadData *) data)->javaInstance;
	const gchar *_path = ((ExportThreadData *) data)->gpath;

        g_print ( "Registering object at %s\n", _path );

	GDBusInterfaceInfo *info = $$$interface.cname$$$_interface_info();

	guint registration_id;
	GError *_error = NULL;

###for method###
	// g_signal_connect (skeleton, "handle-$$$method.sname$$$", G_CALLBACK ($$$interface.jname$$$Skeleton_alert), data);
###end###
                    

	registration_id = g_dbus_connection_register_object (connection,
                                                        _path,
                                                        info, 		// introspection_data->interfaces[0],
                                                        &$$$interface.jname$$$Skeleton_interface_vtable,
                                                        data->obj,      // user_data
                                                        NULL,      // user_data_free_func
														&_error);
    if (registration_id<=0) {
        g_print ( "ERROR: on_bus_acquired(): g_dbus_connection_register_object() failed: %s\n", _error->message );
        return;
    }

/*	
	gboolean _success = g_dbus_interface_skeleton_export((GDBusInterfaceSkeleton *)skeleton, connection, _path, &_error);
	if (!_success) {
        g_print ( "ERROR: on_bus_acquired(): g_dbus_interface_skeleton_export() failed: %s\n", _error->message );
        return;
	}
*/	
    g_print ( "on_bus_acquired(): succeeded: %d\n", registration_id);
}

void $$$interface.jname$$$Skeleton_on_name_acquired(GDBusConnection *connection, const gchar *name, gpointer data) {
    g_print (" * name_acquired: %s\n", name);

    g_thread_new(NULL, $$$interface.jname$$$Skeleton_exit_export_thread, NULL);
}

void $$$interface.jname$$$Skeleton_on_name_lost(GDBusConnection *connection, const gchar *name, gpointer data) {
    g_print (" * name_lost: %s\n", name);
    
    g_thread_new(NULL, $$$interface.jname$$$Skeleton_exit_export_thread, NULL);
}


gpointer $$$interface.jname$$$Skeleton_start_export_thread (void *data) {
    $$$interface.jname$$$Skeleton_export_loop = g_main_loop_new(NULL, FALSE);	  
   
	g_bus_own_name (G_BUS_TYPE_SESSION,  // G_BUS_TYPE_SYSTEM
	  "de.serviceflow.codegenj.$$$interface.uname$$$",   // different to path
	  G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, // G_BUS_NAME_OWNER_FLAGS_NONE,
	  $$$interface.jname$$$Skeleton_on_bus_acquired,
	  $$$interface.jname$$$Skeleton_on_name_acquired,
	  $$$interface.jname$$$Skeleton_on_name_lost,
	  data,
	  NULL); // TODO: Add free function
	  
    g_print (" starting export loop...\n");
    g_main_loop_run($$$interface.jname$$$Skeleton_export_loop);   
	return NULL;
}


JNIEXPORT jobject JNICALL Java_$$$interface.jname$$$Skeleton__1init(JNIEnv *env, jobject thisObj, jstring path) {

	const gchar *_path = (*env)->GetStringUTFChars(env, path, NULL);

	MyObject *myobj = g_object_new (my_object_get_type (), NULL);

/***************
	$$$interface.uname$$$ *skeleton = $$$interface.cname$$$_skeleton_new();

//	g_signal_connect (interface,
//                    "handle-hello-world",
//                    G_CALLBACK (on_handle_hello_world),
//                    some_user_data);

	GError *_error = NULL;
	GDBusConnection *connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM,
                NULL,
                &_error);
	if (connection==NULL || _error!=NULL) {
	    if (_error!=NULL) {
		   jclass _eClass = (*env)->FindClass(env, "java/lang/Error");
	       (*env)->ThrowNew(env, _eClass, _error->message);
		   (*env)->DeleteLocalRef(env, _eClass);	      
	       g_error_free(_error);
	    }
	    else {
		   jclass _eClass = (*env)->FindClass(env, "java/lang/Error");
	       (*env)->ThrowNew(env, _eClass, "Call to g_bus_get_sync() failed. Reason unknown.");
		   (*env)->DeleteLocalRef(env, _eClass);	      
	    }
	}

	_error = NULL;
	if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (skeleton),
                                         connection,
                                         _path,
                                         &_error)) {
	    if (_error!=NULL) {
		   jclass _eClass = (*env)->FindClass(env, "java/lang/Error");
	       (*env)->ThrowNew(env, _eClass, _error->message);
		   (*env)->DeleteLocalRef(env, _eClass);	      
	       g_error_free(_error);
	    }
	    else {
		   jclass _eClass = (*env)->FindClass(env, "java/lang/Error");
	       (*env)->ThrowNew(env, _eClass, "Call to g_dbus_interface_skeleton_export() failed. Reason unknown.");
		   (*env)->DeleteLocalRef(env, _eClass);	      
	    }
    }
***************/

    
	// Start export Thread
	ExportThreadData *td = malloc( sizeof(*td) );
	td->obj = myobj;
	td->javaInstance = &thisObj;
	td->gpath = _path;
    $$$interface.jname$$$Skeleton_export_thread = g_thread_new(NULL, $$$interface.jname$$$Skeleton_start_export_thread, td);
    
	NativeReference *_nref = malloc( sizeof(*_nref) );
	//_nref->value = (GObject *)skeleton;
	jobject _bb = (*env)->NewDirectByteBuffer(env, (void*)_nref, sizeof(NativeReference));
	
	return _bb;	
}


JNIEXPORT void JNICALL Java_$$$interface.jname$$$Skeleton__1destroy(JNIEnv *env, jobject thisObj) {
	// TODO Use g_dbus_interface_skeleton_unexport() to unexport the object.
}

